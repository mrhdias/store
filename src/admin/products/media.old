//
// Last Modification: 2024-06-23 19:23:38
//

// use crate::admin::products::common;
use crate::types::Status;
use crate::utils;

use std::collections::HashMap;
use url::Url;

use axum::{
    extract::{Extension, Path, RawForm, Multipart},
    response::Html,
};

use tera::{
    Tera,
    Context
};

use std::{
    fs,
    fs::File,
    io::Write,
    path::PathBuf,
};

use chrono::Local;
use strum::VariantNames;

fn generate_unique_filename(dir: &std::path::Path, filename: &str) -> PathBuf {
    let mut path = dir.join(filename);
    let mut counter = 1;

    // Extract the base name and extension
    let (base, ext) = match path.extension() {
        Some(ext) => {
            let ext_str = ext.to_str().unwrap_or("");
            let base = path.file_stem().unwrap_or_else(|| path.as_os_str()).to_str().unwrap_or("");
            (base.to_string(), ext_str.to_string())
        }
        None => (filename.to_string(), "".to_string()),
    };

    // Loop to find a unique filename
    while path.exists() {
        let new_filename = format!("{}-{}.{}", base, counter, ext);
        path = dir.join(&new_filename);
        counter += 1;
    }

    path
}

pub async fn update(
    Path(id):Path<i32>,
    Extension(pool): Extension<sqlx::Pool<sqlx::Postgres>>,
    Extension(mut tera): Extension<Tera>,
    RawForm(form): RawForm) -> Html<String> {

    let raw_form_data = String::from_utf8(form.to_vec()).unwrap();

    println!("raw form data: {}", raw_form_data);
    let v: Vec<&str> = raw_form_data.split('&').collect();

    let mut delete = false;
    let mut images: HashMap<i32, HashMap<String, String>> = HashMap::new();
    let mut remove_images: Vec<i32> = Vec::new(); 

    let mut current_key = 0;
    for key_value in v.iter() {
        let key_value: Vec<&str> = key_value.split('=').collect();
        let key = key_value[0];
        let value = key_value[1].replace("+", " ");

        println!("key: {} value: {}", key, value);

        if key == "delete" && value == "yes" {
            delete = true;
            continue;
        }

        if key == "id" {
            current_key = value.parse::<i32>().unwrap();
            images.insert(current_key, HashMap::new());
            continue;
        }

        if current_key > 0 {

            if key == "remove" && value == "yes" {
                println!("remove key: {} value: {} id: {}", key, value, current_key);
                remove_images.push(current_key); // current_key is the image id
                images.remove(&current_key);
                current_key = 0;

                continue;
            }

            if let Some(part) = images.get_mut(&current_key) {
                if key == "name" {
                    part.insert("name".to_string(), value.to_string());
                } else if key == "position" {
                    part.insert("position".to_string(), value.to_string());
                }
            }
        }
    }

    for (id, part) in images.iter() {
        for (key, value) in part.iter() {
            println!("id: {} key: {} value: {}", id, key, value);
            if key == "name" {
                sqlx::query(r#"
                    UPDATE media
                    SET name = $1
                    WHERE id = $2;
                "#)
                    .bind(value)
                    .bind(&id)
                    .execute(&pool)
                    .await
                    .expect("Failed to update image name");
            } else if key == "position" {
                let position: i32 = value.as_str().parse().unwrap();
                sqlx::query(r#"
                    UPDATE product_media
                    SET position = $1
                    WHERE media_id = $2;
                "#)
                    .bind(position)
                    .bind(&id)
                    .execute(&pool)
                    .await
                    .expect("Failed to update image position");
            }
        }
    }

    for id in remove_images.iter() {
        sqlx::query(r#"
            DELETE FROM product_media
            WHERE media_id = $1;
        "#)
            .bind(&id)
            .execute(&pool)
            .await
            .expect(&format!("Failed to remove the product image with id {}", &id));

        if delete {

            let image_src: (String, ) = sqlx::query_as(r#"
                DELETE FROM media
                WHERE id = $1
                RETURNING src;;
            "#)
                .bind(&id)
                .fetch_one(&pool)
                .await
                .expect(&format!("Failed to remove the media image with id {}", &id));


            // http://127.0.0.1:8080/uploads/2024-06-18/file.png
            // let image_src = image_row.get::<String, _>("src");
            let parsed_url = Url::parse(&image_src.0).expect("Failed to parse URL");
            let path = parsed_url.path();
            let file_path = PathBuf::from(path);
            
            if file_path.exists() {
                fs::remove_file(file_path).expect("Failed to remove file");
            }
        }
    }

    let product = common::get_product_to_edit(id, pool)
        .await.expect("Failed to get product data");

    let status_names: &[&str] = Status::VARIANTS;

    tera.register_filter("round_and_format", utils::round_and_format_filter);

    let mut data = Context::new();
    data.insert("product", &product);
    data.insert("status", status_names);
    data.insert("alert", "Product images updated");
    let rendered = tera.render("admin/product.html", &data).unwrap();

    Html(rendered)
}

pub async fn add(
    Path(id):Path<i32>,
    Extension(mut tera): Extension<Tera>,
    Extension(pool): Extension<sqlx::Pool<sqlx::Postgres>>,
    mut multipart: Multipart) -> Html<String> {

    let mut position = 0;

    while let Some(field) = multipart.next_field().await.unwrap() {

        let name = match field.name() {
            Some(n) => n.to_string(),
            None => "".to_string()
        };
    
        println!("name: {:?}", name);

        match name.as_str() {
            // test if file is empty
            "files" => {
                let filename = match field.file_name() {
                    Some(n) => {
                        if n.is_empty() {
                            println!("file name is empty");
                            continue;
                        }
                        n.to_string()
                    },
                    None => {
                        println!("file name not exists");
                        continue;
                    }
                };

                // let content_type = field.content_type().unwrap_or("application/octet-stream").to_string();
                let field_data = field.bytes().await.unwrap();
                
                if field_data.is_empty() {
                    println!("the uploaded file {} is empty", filename);
                    continue;
                }

                let today = Local::now();
                let today_date = today.format("%Y-%m-%d").to_string();

                let mut upload_dir = PathBuf::new();
                upload_dir.push("static");
                upload_dir.push("uploads");
                upload_dir.push(today_date.to_string());

                if !fs::metadata(&upload_dir).is_ok() {
                    fs::create_dir_all(&upload_dir).expect("Couldn't create directory");
                    println!("Directory created: {}", upload_dir.display());
                }

                // test if the file exists and add a suffix
                let filepath = generate_unique_filename(&upload_dir, &filename);

                println!("file path: {}", filepath.display());

                // let file_path = upload_dir.join(&filename);


                let file = File::create(&filepath);
                match file {
                    Ok(mut f) => {
                        f.write_all(&field_data).unwrap();
                    },
                    Err(e) => {
                        println!("Failed to create file: {}", e);
                        continue;
                    }
                };


                let media_row: (i32, ) = sqlx::query_as(r#"
                    INSERT INTO media (src, name, alt)
                    VALUES ($1, $2, $3) RETURNING id;
                "#)
                    .bind(format!("{}/{}/{}/{}",
                        "http://127.0.0.1:8080",
                        "uploads",
                        today_date,
                        filepath.file_name().unwrap().to_string_lossy()))
                    .bind("Unnamed")
                    .bind("Unnamed")
                    .fetch_one(&pool)
                    .await
                    .expect("Failed to insert a new product image in media");


                if id == 0 {
                    continue;
                }

                sqlx::query(r#"
                    INSERT INTO product_media (product_id, media_id, position)
                    VALUES ($1, $2, $3);
                "#)
                    .bind(&id)
                    .bind(&media_row.0)
                    .bind(&position)
                    .execute(&pool)
                    .await
                    .expect("Failed to insert a new product image");

                position += 1;
            },
            _ => println!("Unknown name: {:?}", name),
        };
    }

    let product = common::get_product_to_edit(id, pool)
        .await.expect("Failed to get product data");

    let status_names: &[&str] = Status::VARIANTS;

    tera.register_filter("round_and_format", utils::round_and_format_filter);

    let mut data = Context::new();
    data.insert("product", &product);
    data.insert("status", status_names);
    data.insert("alert", "Product images updated");
    let rendered = tera.render("admin/product.html", &data).unwrap();

    Html(rendered)
}

pub async fn select(
    Path(id):Path<i32>,
    Extension(pool): Extension<sqlx::Pool<sqlx::Postgres>>,
    Extension(tera): Extension<Tera>,
    RawForm(form): RawForm) -> Html<String> {


    Html("Select media".to_string())
}